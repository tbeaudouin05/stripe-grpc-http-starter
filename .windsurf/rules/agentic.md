---
trigger: manual
---

## **Planning Requirements**

1. **Create a Detailed Plan**

   * Your plan must include **all steps** needed to implement the requested feature.
   * If multiple functions will be created, include a **checklist** of each functionâ€™s **name** and **purpose**. This checklist will be used during implementation.

2. **Mandatory Top Section**
   At the very top of the plan, include:

   > You must complete the entire plan without interruption. Continue writing code until the plan is fully implemented. Do not pause, take breaks, or ask the user any questions, as the user is currently unavailable. However, include a section titled **Questions & Assumptions**, where you document any missing information or uncertainties. The user will review and respond to these when they return tomorrow.

3. **Mandatory Last Step**

   * The final step of the plan must always be:

     ```
     Run unit tests with: make test
     ```

4. **Pre-Planning Analysis**

   * First, explore the **project directory structure**.
   * Then, analyze all **relevant files** to gain context and understand repository conventions.
   * Only after this analysis should you create the plan.

---

## **Agentic Instructions**

* Thoroughly explore the **directory structure** and **relevant files** before planning.

* Do **not** ask the user questions (the user is unavailable).

* If you encounter uncertainties:

  1. Ask the question to yourself.
  2. If you cannot answer, make the most reasonable **assumption**.
  3. Document all questions and assumptions in the **Questions & Assumptions** section at the end of the plan.

* Your task is complete **only when the feature is fully implemented** in code. Continue working until it is done.

---

## **Secondary Instructions**

### **Unit & Integration Testing**

* Write unit tests for all modified code.
* Run them with:

  ```
  make test
  ```
* For database-dependent tests:

  * Use mocks generated by `mockgen`.
  * Generate mocks from SQLC queries with:

    ```
    make generate
    ```
* Follow conventions used in existing handlers:

  * One **simple integration test per handler**.
  * Integration tests for third-party services/APIs.
* **Never** attempt to run integration tests.

### **Code Practices**

* Follow **Golang best practices**.
* For logging, use `slog.Info`, `slog.Error`, etc.
* SQLC supports `IN` clauses with arrays via `sqlc.slice`. Example:

  ```sql
  ... WHERE p.fund_id IN (sqlc.slice('fund_ids'))
  ```
* Avoid:

  * Maps (use structs)
  * Pointers
  * Optional proto fields (make all fields required)
* Use `config/config.go` for environment variables.
* Split files larger than **400 lines** into logical smaller files.

### **Function Definitions**

* For third-party service connectors, use:

  ```go
  var FunctionName = func(...) {...}
  ```

  This makes mocking easier during tests.

### **Concurrency**

* Before using concurrency, consider simplifying logic into a single SQL query.
* If parallel execution is needed, follow this pattern:

  ```go
  var (
      mu      sync.Mutex
      pErrors []error
  )
  var grp errgroup.Group
  grp.SetLimit(n)
  for i, d := range req.GetPaymentDetails() {
      i, d := i, d
      grp.Go(func() error {
          err := func2()
          if err != nil {
              mu.Lock()
              pErrors = append(pErrors, fmt.Errorf("item %d: %v", i, err))
              mu.Unlock()
              return nil
          }
          return nil
      })
  }
  if err := grp.Wait(); err != nil {
      return nil, fmt.Errorf("parallel failed: %w", err)
  }
  if len(pErrors) > 0 {
      return nil, fmt.Errorf("errors: %v", pErrors)
  }
  ```

---

## **Exposing gRPC Endpoints via HTTP**

1. **Add HTTP Annotations to `.proto` File**

   * Import `google/api/annotations.proto`.
   * Example:

     ```proto
     import "google/api/annotations.proto";

     service YourService {
       rpc YourMethod(YourRequest) returns (YourResponse) {
         option (google.api.http) = {
           get: "/v1/your-service/method/{id}"
           // For POST requests:
           // post: "/v1/your-service/method"
           // body: "*"
           // For PUT requests:
           // put: "/v1/your-service/method/{id}"
           // body: "*"
         };
       }
     }
     ```

2. **Regenerate Code**

   ```
   make buf
   ```

3. **Register Service Handler in Gateway**
   In `entrypoint/app/server/serverhttp.go`:

   ```go
   if err := yourservicepb.RegisterYourServiceHandler(context.Background(), mux, conn); err != nil {
       slog.Error("failed to register YourService handler", slog.String("error", err.Error()))
       conn.Close()
       return nil
   }
   ```
