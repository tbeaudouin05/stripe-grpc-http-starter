package db

import (
	"context"
	"database/sql"
	"fmt"
    "strconv"

	config "github.com/tbeaudouin05/stripe-trellai/api/config"
	"github.com/tbeaudouin05/stripe-trellai/api/database"
	sqldb "github.com/tbeaudouin05/stripe-trellai/internal/autogenerated/sqldb"
)

var q *sqldb.Queries

func init() {
    if database.GetDB() != nil {
        q = sqldb.New(database.GetDB())
    }
}

// SpendingUnit represents an item to insert into spending_unit table.
type SpendingUnit struct {
    ExternalID     string
    UserExternalID string
    Amount         int
    CreatedAt      int64
}

// AddSpendingUnits inserts items one by one with ON CONFLICT DO NOTHING semantics.
// Returns the total number of rows actually inserted (duplicates are skipped).
// created_at is expected to be in unix milliseconds.
func AddSpendingUnits(items []SpendingUnit) (int, error) {
    ctx := context.Background()
    var total int
    for i, it := range items {
        if it.ExternalID == "" || it.UserExternalID == "" {
            return 0, fmt.Errorf("item %d: missing external_id or user_external_id", i)
        }
        if it.Amount <= 0 {
            return 0, fmt.Errorf("item %d: amount must be > 0", i)
        }
        // created_at must be provided (unix ms)
        if it.CreatedAt == 0 {
            return 0, fmt.Errorf("item %d: created_at is required", i)
        }
        inserted, err := q.InsertSpendingUnit(ctx, sqldb.InsertSpendingUnitParams{
            ExternalID:     it.ExternalID,
            UserExternalID: it.UserExternalID,
            Amount:         int32(it.Amount),
            CreatedAt:      it.CreatedAt,
        })
        if err != nil {
            return 0, fmt.Errorf("failed to insert spending_unit (item %d): %w", i, err)
        }
        switch v := inserted.(type) {
        case int:
            total += v
        case int32:
            total += int(v)
        case int64:
            total += int(v)
        case float64:
            total += int(v)
        case []uint8:
            // some drivers may return numeric aggregates as []byte
            n, perr := strconv.ParseInt(string(v), 10, 64)
            if perr != nil {
                return 0, fmt.Errorf("unexpected inserted type []uint8 parse error: %w", perr)
            }
            total += int(n)
        default:
            return 0, fmt.Errorf("unexpected inserted type %T", v)
        }
    }
    return total, nil
}

// toNullString converts empty strings to NULLs to match nullable columns
func toNullString(s string) sql.NullString {
	if s == "" {
		return sql.NullString{String: "", Valid: false}
	}
	return sql.NullString{String: s, Valid: true}
}

// CheckUserAccount returns whether a user account exists and its stripe subscription ID if it exists
func CheckUserAccount(userExternalID string) (bool, string, error) {
	ctx := context.Background()
	stripeSubscriptionID, err := q.GetSubscriptionIDByUserExternalID(ctx, userExternalID)
	if err == sql.ErrNoRows {
		return false, "", nil
	}
	if err != nil {
		return false, "", fmt.Errorf("failed to check user_account: %w", err)
	}
	if stripeSubscriptionID.Valid {
		return true, stripeSubscriptionID.String, nil
	}
	return true, "", nil
}

// InsertInvalidSubscription inserts a record into invalid_subscription table
func InsertInvalidSubscription(userExternalID, stripeSubscriptionID, stripePlanID, stripeCustomerID string) error {
	ctx := context.Background()
	err := q.InsertInvalidSubscription(ctx, sqldb.InsertInvalidSubscriptionParams{
		UserExternalID:       userExternalID,
		StripeSubscriptionID: toNullString(stripeSubscriptionID),
		StripePlanID:         toNullString(stripePlanID),
		StripeCustomerID:     toNullString(stripeCustomerID),
	})
	if err != nil {
		return fmt.Errorf("failed to insert invalid_subscription: %w", err)
	}
	return nil
}

// UpsertUserAccount upserts a record into user_account table
func UpsertUserAccount(userExternalID, stripeSubscriptionID, stripePlanID, stripeCustomerID string) error {
	ctx := context.Background()
	err := q.UpsertUserAccount(ctx, sqldb.UpsertUserAccountParams{
		UserExternalID:       userExternalID,
		StripeSubscriptionID: toNullString(stripeSubscriptionID),
		StripePlanID:         toNullString(stripePlanID),
		StripeCustomerID:     toNullString(stripeCustomerID),
	})
	if err != nil {
		return fmt.Errorf("failed to upsert user_account: %w", err)
	}
	return nil
}

const AccountWithoutSubscriptionID = "accountWithoutSubscription"

// UserAccount represents a record from the user_account table
// All fields are exported for JSON marshalling if needed.
type UserAccount struct {
	UserExternalID       string `json:"user_external_id"`
	StripeSubscriptionID string `json:"stripe_subscription_id"`
	StripePlanID         string `json:"stripe_plan_id"`
	StripeCustomerID     string `json:"stripe_customer_id"`
	CreatedAt            int64  `json:"created_at"`
	UpdatedAt            int64  `json:"updated_at"`
}

// GetUserAccount retrieves a user_account record by external ID
func GetUserAccount(userExternalID string) (UserAccount, error) {
	ctx := context.Background()
	row, err := q.GetUserAccount(ctx, userExternalID)
	if err == sql.ErrNoRows {
		return UserAccount{UserExternalID: AccountWithoutSubscriptionID}, nil
	}
	if err != nil {
		return UserAccount{}, fmt.Errorf("error scanning user_account row: %w", err)
	}

	ua := UserAccount{
		UserExternalID:       row.UserExternalID,
		StripeSubscriptionID: "",
		StripePlanID:         "",
		StripeCustomerID:     "",
		CreatedAt:            row.CreatedAt,
		UpdatedAt:            row.UpdatedAt,
	}
	if row.StripeSubscriptionID.Valid {
		ua.StripeSubscriptionID = row.StripeSubscriptionID.String
	}
	if row.StripePlanID.Valid {
		ua.StripePlanID = row.StripePlanID.String
	}
	if row.StripeCustomerID.Valid {
		ua.StripeCustomerID = row.StripeCustomerID.String
	}
	return ua, nil
}

// GetFreeCredit retrieves free_credit amount for a user.
// If no record exists, it creates one with the default InitialFreeCredit value.
func GetFreeCredit(userExternalID string) (int, error) {
	ctx := context.Background()
	credit, err := q.UpsertAndGetFreeCredit(ctx, sqldb.UpsertAndGetFreeCreditParams{
		UserExternalID: userExternalID,
		Credit:         int32(config.InitialFreeCredit),
	})
	if err != nil {
		return 0, fmt.Errorf("error getting/creating free_credit: %w", err)
	}
	return int(credit), nil
}

// CountUnitsBetween sums spending units for a given user between start and end (inclusive).
func CountUnitsBetween(userExternalID string, start, end int64) (int, error) {
	ctx := context.Background()
	c, err := q.CountUnitsBetween(ctx, sqldb.CountUnitsBetweenParams{
		UserExternalID: userExternalID,
		CreatedAt:      start,
		CreatedAt_2:    end,
	})
	if err != nil {
		return 0, fmt.Errorf("error summing spending units: %w", err)
	}
	switch v := c.(type) {
	case int64:
		return int(v), nil
	case int32:
		return int(v), nil
	case int:
		return v, nil
	case float64:
		return int(v), nil
	case []uint8:
		// some drivers may return numeric aggregates as []byte
		i, perr := strconv.ParseInt(string(v), 10, 64)
		if perr != nil {
			return 0, fmt.Errorf("unexpected count type []uint8 parse error: %w", perr)
		}
		return int(i), nil
	case nil:
		return 0, nil
	default:
		return 0, fmt.Errorf("unexpected count type %T", v)
	}
}
