package db

import (
	"context"
	"database/sql"
	"fmt"
	"strconv"
	"crypto/sha256"
	"encoding/hex"

	config "github.com/tbeaudouin05/stripe-trellai/api/config"
	"github.com/tbeaudouin05/stripe-trellai/api/database"
	sqldb "github.com/tbeaudouin05/stripe-trellai/internal/autogenerated/sqldb"
)

var q *sqldb.Queries

func init() {
    if database.GetDB() != nil {
        q = sqldb.New(database.GetDB())
    }
}

// SpendingUnit represents an item to insert into spending_unit table.
type SpendingUnit struct {
    ExternalID     string
    UserExternalID string
    Amount         int
    CreatedAt      int64
}

// hashExternalID returns a deterministic SHA-256 hex digest of the provided
// external identifier. This allows the backend to avoid storing raw values
// (e.g., emails) while preserving idempotency and uniqueness semantics.
func hashExternalID(s string) string {
    sum := sha256.Sum256([]byte(s))
    return hex.EncodeToString(sum[:])
}

// AddSpendingUnits inserts items one by one with ON CONFLICT DO NOTHING semantics.
// Returns the total number of rows actually inserted (duplicates are skipped).
// created_at is expected to be in unix milliseconds.
func AddSpendingUnits(items []SpendingUnit) (int, error) {
    ctx := context.Background()
    // Ensure we only initialize free_credit once per user in this batch
    ensured := make(map[string]bool)
    var total int
    for i, it := range items {
        if it.ExternalID == "" || it.UserExternalID == "" {
            return 0, fmt.Errorf("item %d: missing external_id or user_external_id", i)
        }
        if it.Amount <= 0 {
            return 0, fmt.Errorf("item %d: amount must be > 0", i)
        }
        // created_at must be provided (unix ms)
        if it.CreatedAt == 0 {
            return 0, fmt.Errorf("item %d: created_at is required", i)
        }
        // lazily ensure a free_credit row exists for this user.
        // Pass RAW user ID here because GetFreeCredit hashes internally.
        if !ensured[it.UserExternalID] {
            if _, err := GetFreeCredit(it.UserExternalID); err != nil {
                return 0, fmt.Errorf("failed to ensure free credit for user %q: %w", it.UserExternalID, err)
            }
            ensured[it.UserExternalID] = true
        }

        // Always hash external_id before persisting to avoid storing raw identifiers.
        hashedExternalID := hashExternalID(it.ExternalID)
        // Hash user ID for direct SQL inserts below
        hashedUserID := hashExternalID(it.UserExternalID)

        inserted, err := q.InsertSpendingUnit(ctx, sqldb.InsertSpendingUnitParams{
            ExternalID:     hashedExternalID,
            UserExternalID: hashedUserID,
            Amount:         int32(it.Amount),
            CreatedAt:      it.CreatedAt,
        })
        if err != nil {
            return 0, fmt.Errorf("failed to insert spending_unit (item %d): %w", i, err)
        }
        // Normalize the inserted value and detect whether this row was actually inserted
        insertedInt := 0
        switch v := inserted.(type) {
        case int:
            insertedInt = v
        case int32:
            insertedInt = int(v)
        case int64:
            insertedInt = int(v)
        case float64:
            insertedInt = int(v)
        case []uint8:
            // some drivers may return numeric aggregates as []byte
            n, perr := strconv.ParseInt(string(v), 10, 64)
            if perr != nil {
                return 0, fmt.Errorf("unexpected inserted type []uint8 parse error: %w", perr)
            }
            insertedInt = int(n)
        default:
            return 0, fmt.Errorf("unexpected inserted type %T", v)
        }
        total += insertedInt

        // If we actually inserted the spending unit, consume free credit for this user by 'amount'
        if insertedInt > 0 {
            if err := q.ConsumeFreeCredit(ctx, sqldb.ConsumeFreeCreditParams{
                UserExternalID: hashedUserID,
                Credit:         int32(it.Amount),
            }); err != nil {
                return 0, fmt.Errorf("failed to consume free credit (item %d): %w", i, err)
            }
        }
    }
    return total, nil
}

// toNullString converts empty strings to NULLs to match nullable columns
func toNullString(s string) sql.NullString {
	if s == "" {
		return sql.NullString{String: "", Valid: false}
	}
	return sql.NullString{String: s, Valid: true}
}

// CheckUserAccount returns whether a user account exists and its stripe subscription ID if it exists
func CheckUserAccount(userExternalID string) (bool, string, error) {
    ctx := context.Background()
    // hash the user ID before querying
    hashed := hashExternalID(userExternalID)
    stripeSubscriptionID, err := q.GetSubscriptionIDByUserExternalID(ctx, hashed)
    if err == sql.ErrNoRows {
        return false, "", nil
    }
    if err != nil {
        return false, "", fmt.Errorf("failed to check user_account: %w", err)
	}
	if stripeSubscriptionID.Valid {
		return true, stripeSubscriptionID.String, nil
	}
	return true, "", nil
}

// InsertInvalidSubscription inserts a record into invalid_subscription table
func InsertInvalidSubscription(userExternalID, stripeSubscriptionID, stripePlanID, stripeCustomerID string) error {
    ctx := context.Background()
    // hash the user ID before inserting
    hashed := hashExternalID(userExternalID)
    err := q.InsertInvalidSubscription(ctx, sqldb.InsertInvalidSubscriptionParams{
        UserExternalID:       hashed,
        StripeSubscriptionID: toNullString(stripeSubscriptionID),
        StripePlanID:         toNullString(stripePlanID),
        StripeCustomerID:     toNullString(stripeCustomerID),
    })
    if err != nil {
        return fmt.Errorf("failed to insert invalid_subscription: %w", err)
    }
    return nil
}

// UpsertUserAccount upserts a record into user_account table
func UpsertUserAccount(userExternalID, stripeSubscriptionID, stripePlanID, stripeCustomerID string) error {
    ctx := context.Background()
    // hash the user ID before upserting
    hashed := hashExternalID(userExternalID)
    err := q.UpsertUserAccount(ctx, sqldb.UpsertUserAccountParams{
        UserExternalID:       hashed,
        StripeSubscriptionID: toNullString(stripeSubscriptionID),
        StripePlanID:         toNullString(stripePlanID),
        StripeCustomerID:     toNullString(stripeCustomerID),
    })
    if err != nil {
        return fmt.Errorf("failed to upsert user_account: %w", err)
    }
    return nil
}

const AccountWithoutSubscriptionID = "accountWithoutSubscription"

// UserAccount represents a record from the user_account table
// All fields are exported for JSON marshalling if needed.
type UserAccount struct {
	UserExternalID       string `json:"user_external_id"`
	StripeSubscriptionID string `json:"stripe_subscription_id"`
	StripePlanID         string `json:"stripe_plan_id"`
	StripeCustomerID     string `json:"stripe_customer_id"`
	CreatedAt            int64  `json:"created_at"`
	UpdatedAt            int64  `json:"updated_at"`
}

// GetUserAccount retrieves a user_account record by external ID
func GetUserAccount(userExternalID string) (UserAccount, error) {
    ctx := context.Background()
    // hash the user ID before querying
    hashed := hashExternalID(userExternalID)
    row, err := q.GetUserAccount(ctx, hashed)
    if err == sql.ErrNoRows {
        return UserAccount{UserExternalID: AccountWithoutSubscriptionID}, nil
    }
    if err != nil {
        return UserAccount{}, fmt.Errorf("error scanning user_account row: %w", err)
	}

	ua := UserAccount{
		UserExternalID:       row.UserExternalID,
		StripeSubscriptionID: "",
		StripePlanID:         "",
		StripeCustomerID:     "",
		CreatedAt:            row.CreatedAt,
		UpdatedAt:            row.UpdatedAt,
	}
	if row.StripeSubscriptionID.Valid {
		ua.StripeSubscriptionID = row.StripeSubscriptionID.String
	}
	if row.StripePlanID.Valid {
		ua.StripePlanID = row.StripePlanID.String
	}
	if row.StripeCustomerID.Valid {
		ua.StripeCustomerID = row.StripeCustomerID.String
	}
	return ua, nil
}

// GetFreeCredit retrieves free_credit amount for a user.
// If no record exists, it creates one with the default InitialFreeCredit value.
func GetFreeCredit(userExternalID string) (int, error) {
    ctx := context.Background()
    // hash the user ID before querying/upserting
    hashed := hashExternalID(userExternalID)
    credit, err := q.UpsertAndGetFreeCredit(ctx, sqldb.UpsertAndGetFreeCreditParams{
        UserExternalID: hashed,
        Credit:         int32(config.InitialFreeCredit),
    })
    if err != nil {
        return 0, fmt.Errorf("error getting/creating free_credit: %w", err)
    }
    return int(credit), nil
}

// CountUnitsBetween sums spending units for a given user between start and end (inclusive).
func CountUnitsBetween(userExternalID string, start, end int64) (int, error) {
    ctx := context.Background()
    // hash the user ID before querying
    hashed := hashExternalID(userExternalID)
    c, err := q.CountUnitsBetween(ctx, sqldb.CountUnitsBetweenParams{
        UserExternalID: hashed,
        CreatedAt:      start,
        CreatedAt_2:    end,
    })
    if err != nil {
        return 0, fmt.Errorf("error summing spending units: %w", err)
	}
	switch v := c.(type) {
	case int64:
		return int(v), nil
	case int32:
		return int(v), nil
	case int:
		return v, nil
	case float64:
		return int(v), nil
	case []uint8:
		// some drivers may return numeric aggregates as []byte
		i, perr := strconv.ParseInt(string(v), 10, 64)
		if perr != nil {
			return 0, fmt.Errorf("unexpected count type []uint8 parse error: %w", perr)
		}
		return int(i), nil
	case nil:
		return 0, nil
	default:
		return 0, fmt.Errorf("unexpected count type %T", v)
	}
}
