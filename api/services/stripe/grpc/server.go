package grpcserver

import (
    "context"
    "fmt"
    "log/slog"
    "strings"

    "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
    "github.com/stripe/stripe-go/webhook"
    "google.golang.org/genproto/googleapis/api/httpbody"
    "google.golang.org/grpc/metadata"
    "google.golang.org/protobuf/types/known/emptypb"

    bootstrap "github.com/tbeaudouin05/stripe-trellai/api/bootstrap"
    config "github.com/tbeaudouin05/stripe-trellai/api/config"
    appsvc "github.com/tbeaudouin05/stripe-trellai/api/services/stripe/app"
    stripedb "github.com/tbeaudouin05/stripe-trellai/api/services/stripe/db"
    stripev1 "github.com/tbeaudouin05/stripe-trellai/internal/autogenerated/proto/stripe/v1"
)

// ConstructEvent is a replaceable function wrapper around webhook.ConstructEvent for testing.
var ConstructEvent = webhook.ConstructEvent

// Server implements stripev1.StripeServiceServer.
// It adapts the existing app service to gRPC.
type Server struct {
    stripev1.UnimplementedStripeServiceServer
    app appsvc.Service
}

// New creates a new gRPC server for Stripe using the provided app service.
func New(app appsvc.Service) Server { return Server{app: app} }

// RegisterGateway registers the HTTP gateway handlers on the provided mux.
// It configures header forwarding for Stripe-Signature.
func RegisterGateway(ctx context.Context, mux *runtime.ServeMux, srv Server) error {
    return stripev1.RegisterStripeServiceHandlerServer(ctx, mux, srv)
}

// HeaderMatcher forwards Stripe-Signature header into gRPC metadata.
func HeaderMatcher(key string) (string, bool) {
    if strings.EqualFold(key, "Stripe-Signature") {
        return "stripe-signature", true
    }
    return runtime.DefaultHeaderMatcher(key)
}

// HandleWebhookPayload verifies the Stripe signature and dispatches the event.
func HandleWebhookPayload(app appsvc.Service, payload []byte, signature string) error {
    if signature == "" {
        return fmt.Errorf("missing Stripe-Signature header")
    }
    endpointSecret := config.AppConfig.StripeWebhookSecret
    event, err := ConstructEvent(payload, signature, endpointSecret)
    if err != nil {
        return fmt.Errorf("error verifying webhook signature: %v", err)
    }
    switch event.Type {
    case "checkout.session.completed":
        if err := app.HandleCheckoutSessionCompleted(event); err != nil {
            return err
        }
    default:
        slog.Info("Unhandled event type", "type", event.Type)
    }
    return nil
}

// CancelSubscription implements RPC.
func (s Server) CancelSubscription(ctx context.Context, req *stripev1.CancelSubscriptionRequest) (*stripev1.CancelSubscriptionResponse, error) {
    if err := bootstrap.Ensure(); err != nil {
        return nil, fmt.Errorf("initialization error: %v", err)
    }
    if req.GetSubscriptionId() == "" {
        return nil, fmt.Errorf("subscription_id is required")
    }
    if err := s.app.CancelSubscription(req.GetSubscriptionId()); err != nil {
        return nil, err
    }
    return &stripev1.CancelSubscriptionResponse{}, nil
}

// VerifySubscriptionValidity implements RPC.
func (s Server) VerifySubscriptionValidity(ctx context.Context, req *stripev1.VerifySubscriptionValidityRequest) (*stripev1.VerifySubscriptionValidityResponse, error) {
    if err := bootstrap.Ensure(); err != nil {
        return nil, fmt.Errorf("initialization error: %v", err)
    }
    if req.GetUserExternalId() == "" {
        return nil, fmt.Errorf("user_external_id is required")
    }
    resp, err := s.app.VerifySubscription(req.GetUserExternalId())
    if err != nil {
        return nil, err
    }
    return &stripev1.VerifySubscriptionValidityResponse{
        IsValidSubscription: resp.IsValidSubscription,
        InvalidityType:      string(resp.InvalidityType),
        ValidityType:        string(resp.ValidityType),
        StripeCustomerEmail: resp.StripeCustomerEmail,
    }, nil
}

// HandleWebhook implements RPC handling of Stripe webhooks.
// Requires the "Stripe-Signature" header to be forwarded via grpc-gateway.
func (s Server) HandleWebhook(ctx context.Context, body *httpbody.HttpBody) (*emptypb.Empty, error) {
    // Early log to confirm endpoint entry on Fly.io and other environments
    slog.Info("HandleWebhook: start", "content_type", body.GetContentType(), "data_len", len(body.GetData()))
    if err := bootstrap.Ensure(); err != nil {
        return nil, fmt.Errorf("initialization error: %v", err)
    }
    md, _ := metadata.FromIncomingContext(ctx)
    sigVals := md.Get("stripe-signature")
    var signature string
    if len(sigVals) > 0 {
        signature = sigVals[0]
    }
    if err := HandleWebhookPayload(s.app, body.GetData(), signature); err != nil {
        return nil, err
    }
    return &emptypb.Empty{}, nil
}

// AddSpendingUnits implements RPC to insert spending units in batch.
func (s Server) AddSpendingUnits(ctx context.Context, req *stripev1.AddSpendingUnitsRequest) (*stripev1.AddSpendingUnitsResponse, error) {
    if err := bootstrap.Ensure(); err != nil {
        return nil, fmt.Errorf("initialization error: %v", err)
    }
    if req == nil || len(req.GetItems()) == 0 {
        return nil, fmt.Errorf("items is required")
    }
    items := make([]stripedb.SpendingUnit, 0, len(req.GetItems()))
    for i, it := range req.GetItems() {
        if it.GetExternalId() == "" || it.GetUserExternalId() == "" {
            return nil, fmt.Errorf("item %d: external_id and user_external_id are required", i)
        }
        if it.GetAmount() <= 0 {
            return nil, fmt.Errorf("item %d: amount must be > 0", i)
        }
        if it.GetCreatedAt() == 0 {
            return nil, fmt.Errorf("item %d: created_at is required", i)
        }
        items = append(items, stripedb.SpendingUnit{
            ExternalID:     it.GetExternalId(),
            UserExternalID: it.GetUserExternalId(),
            Amount:         int(it.GetAmount()),
            CreatedAt:      it.GetCreatedAt(),
        })
    }
    n, err := s.app.AddSpendingUnits(items)
    if err != nil {
        return nil, err
    }
    return &stripev1.AddSpendingUnitsResponse{Inserted: int32(n)}, nil
}
