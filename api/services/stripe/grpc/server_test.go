package grpcserver

import (
	"context"
	"testing"

	stripe "github.com/stripe/stripe-go"
	config "github.com/tbeaudouin05/stripe-trellai/api/config"
	app "github.com/tbeaudouin05/stripe-trellai/api/services/stripe/app"
	stripedb "github.com/tbeaudouin05/stripe-trellai/api/services/stripe/db"
	stripev1 "github.com/tbeaudouin05/stripe-trellai/internal/autogenerated/proto/stripe/v1"
	"google.golang.org/genproto/googleapis/api/httpbody"
	"google.golang.org/grpc/metadata"
)

// stubService implements app.Service with function fields.
type stubService struct {
	CancelFn func(string) error
	VerifyFn func(string) (app.VerifySubscriptionResponse, error)
	HandleFn func(stripe.Event) error
	AddUnitsFn func([]stripedb.SpendingUnit) (int, error)
}

func (s stubService) CancelSubscription(id string) error {
	if s.CancelFn != nil {
		return s.CancelFn(id)
	}
	return nil
}

func (s stubService) VerifySubscription(userExternalID string) (app.VerifySubscriptionResponse, error) {
	if s.VerifyFn != nil {
		return s.VerifyFn(userExternalID)
	}
	return app.VerifySubscriptionResponse{}, nil
}

func (s stubService) HandleCheckoutSessionCompleted(e stripe.Event) error {
	if s.HandleFn != nil {
		return s.HandleFn(e)
	}
	return nil
}

func (s stubService) AddSpendingUnits(items []stripedb.SpendingUnit) (int, error) {
	if s.AddUnitsFn != nil {
		return s.AddUnitsFn(items)
	}
	return 0, nil
}

func ensureConfig(t *testing.T) {
	t.Helper()
	if config.AppConfig == nil {
		cfg, err := config.LoadConfig()
		if err != nil {
			t.Fatalf("failed to load config: %v", err)
		}
		config.AppConfig = cfg
	}
}

func TestCancelSubscription_OK(t *testing.T) {
	ensureConfig(t)
	var got string
	srv := New(stubService{CancelFn: func(id string) error {
		got = id
		return nil
	}})
	_, err := srv.CancelSubscription(context.Background(), &stripev1.CancelSubscriptionRequest{SubscriptionId: "sub_123"})
	if err != nil {
		t.Fatalf("CancelSubscription returned error: %v", err)
	}
	if got != "sub_123" {
		t.Fatalf("expected sub id 'sub_123', got %q", got)
	}
}

func TestVerifySubscriptionValidity_OK(t *testing.T) {
	ensureConfig(t)
	resp := app.VerifySubscriptionResponse{
		IsValidSubscription: true,
		InvalidityType:      app.InvalidityTypeNoSubscription,
		ValidityType:        app.ValidityTypeFreeTier,
		StripeCustomerEmail: "user@example.com",
	}
	srv := New(stubService{VerifyFn: func(uid string) (app.VerifySubscriptionResponse, error) { return resp, nil }})
	got, err := srv.VerifySubscriptionValidity(context.Background(), &stripev1.VerifySubscriptionValidityRequest{UserExternalId: "u1"})
	if err != nil {
		t.Fatalf("VerifySubscriptionValidity returned error: %v", err)
	}
	if !got.GetIsValidSubscription() || got.GetValidityType() != string(resp.ValidityType) || got.GetStripeCustomerEmail() != resp.StripeCustomerEmail {
		t.Fatalf("unexpected response: %+v", got)
	}
}

func TestHandleWebhook_MissingSignature(t *testing.T) {
	ensureConfig(t)
	srv := New(stubService{})
	_, err := srv.HandleWebhook(context.Background(), &httpbody.HttpBody{Data: []byte("{}")})
	if err == nil {
		t.Fatalf("expected error for missing signature, got nil")
	}
}

func TestHandleWebhook_Success_WithStubbedConstructEvent(t *testing.T) {
	ensureConfig(t)
	// Stub ConstructEvent to bypass signature verification and return a minimal event
	orig := ConstructEvent
	ConstructEvent = func(payload []byte, sig string, secret string) (stripe.Event, error) {
		return stripe.Event{Type: "checkout.session.completed"}, nil
	}
	t.Cleanup(func() { ConstructEvent = orig })

	called := false
	srv := New(stubService{HandleFn: func(e stripe.Event) error {
		called = true
		return nil
	}})
	md := metadata.New(map[string]string{"stripe-signature": "t=1,v1=abc"})
	ctx := metadata.NewIncomingContext(context.Background(), md)
	_, err := srv.HandleWebhook(ctx, &httpbody.HttpBody{Data: []byte("{}")})
	if err != nil {
		t.Fatalf("HandleWebhook returned error: %v", err)
	}
	if !called {
		t.Fatalf("expected HandleCheckoutSessionCompleted to be called")
	}
}
