package grpcserver

import (
	"context"
	"testing"
	"time"

	stripev1 "github.com/tbeaudouin05/stripe-trellai/internal/autogenerated/proto/stripe/v1"
	"google.golang.org/genproto/googleapis/api/httpbody"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
)

// remoteGRPCAddr returns the public gRPC endpoint (TLS) of the Fly deployment.
func remoteGRPCAddr() string {
	return "ai-mails-backend.fly.dev:8443"
}

func dialRemoteGRPC(t *testing.T) *grpc.ClientConn {
	t.Helper()
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	t.Cleanup(cancel)
	creds := credentials.NewClientTLSFromCert(nil, "ai-mails-backend.fly.dev")
	conn, err := grpc.DialContext(ctx, remoteGRPCAddr(), grpc.WithTransportCredentials(creds), grpc.WithBlock())
	if err != nil {
		t.Fatalf("failed to dial remote gRPC: %v", err)
	}
	t.Cleanup(func() { _ = conn.Close() })
	return conn
}

func TestCancelSubscriptionGRPC_Remote_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in -short mode")
	}
	conn := dialRemoteGRPC(t)
	client := stripev1.NewStripeServiceClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	_, err := client.CancelSubscription(ctx, &stripev1.CancelSubscriptionRequest{SubscriptionId: ""})
	if err == nil {
		t.Fatalf("expected error for invalid subscription_id, got nil")
	}
}

func TestVerifySubscriptionValidityGRPC_Remote_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in -short mode")
	}
	conn := dialRemoteGRPC(t)
	client := stripev1.NewStripeServiceClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	_, err := client.VerifySubscriptionValidity(ctx, &stripev1.VerifySubscriptionValidityRequest{UserExternalId: ""})
	if err == nil {
		t.Fatalf("expected error for invalid user_external_id, got nil")
	}
}

func TestHandleWebhookGRPC_Remote_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in -short mode")
	}
	conn := dialRemoteGRPC(t)
	client := stripev1.NewStripeServiceClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	// Intentionally omit Stripe-Signature metadata to ensure the server returns an error
	_, err := client.HandleWebhook(ctx, &httpbody.HttpBody{ContentType: "application/json", Data: []byte("{}")})
	if err == nil {
		t.Fatalf("expected error when missing Stripe-Signature, got nil")
	}
}

func TestAddSpendingUnitsGRPC_Remote_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in -short mode")
	}
	conn := dialRemoteGRPC(t)
	client := stripev1.NewStripeServiceClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	_, err := client.AddSpendingUnits(ctx, &stripev1.AddSpendingUnitsRequest{Items: []*stripev1.SpendingUnit{}})
	if err == nil {
		t.Fatalf("expected error for empty items, got nil")
	}
}
