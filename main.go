package main

import (
    "context"
    "log/slog"
    "net"
    "fmt"
    "net/http"
    "os"
    "sync"
    "time"

    "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
    "google.golang.org/grpc"

    bootstrap "github.com/tbeaudouin05/stripe-trellai/api/bootstrap"
    cfg "github.com/tbeaudouin05/stripe-trellai/api/config"
    grpcserver "github.com/tbeaudouin05/stripe-trellai/api/services/stripe/grpc"
    stripev1 "github.com/tbeaudouin05/stripe-trellai/internal/autogenerated/proto/stripe/v1"
)

// grpcLoggingUnaryInterceptor logs incoming gRPC calls and their outcome.
func grpcLoggingUnaryInterceptor(
    ctx context.Context,
    req any,
    info *grpc.UnaryServerInfo,
    handler grpc.UnaryHandler,
) (any, error) {
    start := time.Now()
    resp, err := handler(ctx, req)
    dur := time.Since(start)
    if err != nil {
        slog.Error("gRPC request failed", slog.String("method", info.FullMethod), slog.String("duration", dur.String()), slog.String("error", err.Error()))
    } else {
        slog.Info("gRPC request handled", slog.String("method", info.FullMethod), slog.String("duration", dur.String()))
    }
    return resp, err
}

// httpLoggingMiddleware wraps an http.Handler to log requests.
func httpLoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next.ServeHTTP(w, r)
        dur := time.Since(start)
        slog.Info("HTTP request handled", slog.String("method", r.Method), slog.String("path", r.URL.Path), slog.String("duration", dur.String()))
    })
}

func main() {
    // Initialize config, DB, and services
    if err := bootstrap.Ensure(); err != nil {
        slog.Error("Failed to initialize app", slog.String("error", err.Error()))
        os.Exit(1)
    }

    // Resolve ports
    httpPort := cfg.AppConfig.HTTPPort
    grpcPort := cfg.AppConfig.GRPCPort

    // Construct service implementation
    stripeSvc := bootstrap.GetStripeService()
    srv := grpcserver.New(stripeSvc)

    var wg sync.WaitGroup
    wg.Add(2)

    // Start gRPC server
    go func() {
        defer wg.Done()
        lis, err := net.Listen("tcp", ":"+grpcPort)
        if err != nil {
            slog.Error("failed to listen for gRPC", slog.String("error", err.Error()), slog.String("port", grpcPort))
            os.Exit(1)
        }
        g := grpc.NewServer(grpc.UnaryInterceptor(grpcLoggingUnaryInterceptor))
        stripev1.RegisterStripeServiceServer(g, srv)
        slog.Info("gRPC server listening", slog.String("address", ":"+grpcPort))
        if err := g.Serve(lis); err != nil {
            slog.Error("failed to serve gRPC", slog.String("error", err.Error()))
            os.Exit(1)
        }
    }()

    // Start HTTP gateway server (in-process handler registration)
    go func() {
        defer wg.Done()
        mux := runtime.NewServeMux(runtime.WithIncomingHeaderMatcher(grpcserver.HeaderMatcher))
        if err := grpcserver.RegisterGateway(context.Background(), mux, srv); err != nil {
            slog.Error("failed to register HTTP gateway", slog.String("error", err.Error()))
            os.Exit(1)
        }
        addr := fmt.Sprintf(":%s", httpPort)
        slog.Info("HTTP Gateway server listening", slog.String("address", addr))
        if err := http.ListenAndServe(addr, httpLoggingMiddleware(mux)); err != nil {
            slog.Error("failed to serve HTTP Gateway", slog.String("error", err.Error()))
            os.Exit(1)
        }
    }()

    wg.Wait()
}
