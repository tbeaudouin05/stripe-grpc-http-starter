package main

import (
	"context"
	"embed"
	"fmt"
	"io"
	"log/slog"
	"net"
	"net/http"
	"os"
	"sync"
	"time"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"google.golang.org/grpc"

	bootstrap "github.com/tbeaudouin05/stripe-trellai/api/bootstrap"
	cfg "github.com/tbeaudouin05/stripe-trellai/api/config"
	grpcserver "github.com/tbeaudouin05/stripe-trellai/api/services/stripe/grpc"
	stripev1 "github.com/tbeaudouin05/stripe-trellai/internal/autogenerated/proto/stripe/v1"
)

// grpcLoggingUnaryInterceptor logs incoming gRPC calls and their outcome.
func grpcLoggingUnaryInterceptor(
	ctx context.Context,
	req any,
	info *grpc.UnaryServerInfo,
	handler grpc.UnaryHandler,
) (any, error) {
	start := time.Now()
	resp, err := handler(ctx, req)
	dur := time.Since(start)
	if err != nil {
		slog.Error("gRPC request failed", slog.String("method", info.FullMethod), slog.String("duration", dur.String()), slog.String("error", err.Error()))
	} else {
		slog.Info("gRPC request handled", slog.String("method", info.FullMethod), slog.String("duration", dur.String()))
	}
	return resp, err
}

// httpLoggingMiddleware wraps an http.Handler to log requests.
func httpLoggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		next.ServeHTTP(w, r)
		dur := time.Since(start)
		slog.Info("HTTP request handled", slog.String("method", r.Method), slog.String("path", r.URL.Path), slog.String("duration", dur.String()))
	})
}

//go:embed html/*.html html/*.svg
var embeddedHTML embed.FS

// serveHTMLPage reads an embedded HTML file, rewrites links if needed, and writes it to the response.
func serveHTMLPage(w http.ResponseWriter, filename string) {
	b, err := embeddedHTML.ReadFile(filename)
	if err != nil {
		http.Error(w, "not found", http.StatusNotFound)
		return
	}
	html := string(b)
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write([]byte(html))
}

func main() {
	// Configure structured logging to stdout so Fly.io captures logs reliably
	slog.SetDefault(slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelInfo})))

	// Initialize config, DB, and services
	if err := bootstrap.Ensure(); err != nil {
		slog.Error("Failed to initialize app", slog.String("error", err.Error()))
		os.Exit(1)
	}

	// Resolve ports
	httpPort := cfg.AppConfig.HTTPPort
	grpcPort := cfg.AppConfig.GRPCPort

	// Construct service implementation
	stripeSvc := bootstrap.GetStripeService()
	srv := grpcserver.New(stripeSvc)

	slog.Info("server starting", slog.String("http_port", httpPort), slog.String("grpc_port", grpcPort))

	var wg sync.WaitGroup
	wg.Add(2)

	// Start gRPC server
	go func() {
		defer wg.Done()
		lis, err := net.Listen("tcp", ":"+grpcPort)
		if err != nil {
			slog.Error("failed to listen for gRPC", slog.String("error", err.Error()), slog.String("port", grpcPort))
			os.Exit(1)
		}
		g := grpc.NewServer(grpc.UnaryInterceptor(grpcLoggingUnaryInterceptor))
		stripev1.RegisterStripeServiceServer(g, srv)
		slog.Info("gRPC server listening", slog.String("address", ":"+grpcPort))
		if err := g.Serve(lis); err != nil {
			slog.Error("failed to serve gRPC", slog.String("error", err.Error()))
			os.Exit(1)
		}
	}()

	// Start HTTP gateway server (in-process handler registration)
	go func() {
		defer wg.Done()
		gwMux := runtime.NewServeMux(runtime.WithIncomingHeaderMatcher(grpcserver.HeaderMatcher))
		if err := grpcserver.RegisterGateway(context.Background(), gwMux, srv); err != nil {
			slog.Error("failed to register HTTP gateway", slog.String("error", err.Error()))
			os.Exit(1)
		}
		// Root mux: mount a raw HTTP handler for Stripe webhook to read the payload directly
		root := http.NewServeMux()
        // Favicon: serve embedded SVG and redirect .ico to .svg
        root.Handle("/favicon.svg", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            if r.Method != http.MethodGet {
                http.NotFound(w, r)
                return
            }
            b, err := embeddedHTML.ReadFile("html/favicon.svg")
            if err != nil {
                http.NotFound(w, r)
                return
            }
            w.Header().Set("Content-Type", "image/svg+xml")
            w.WriteHeader(http.StatusOK)
            _, _ = w.Write(b)
        }))
        root.Handle("/favicon.ico", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Permanent redirect to SVG favicon
            http.Redirect(w, r, "/favicon.svg", http.StatusMovedPermanently)
        }))
		// Static policy/support pages (also available with .html suffix)
		root.Handle("/privacy", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				http.NotFound(w, r)
				return
			}
			serveHTMLPage(w, "html/privacy.html")
		}))
		root.Handle("/privacy.html", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				http.NotFound(w, r)
				return
			}
			serveHTMLPage(w, "html/privacy.html")
		}))
		root.Handle("/terms", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				http.NotFound(w, r)
				return
			}
			serveHTMLPage(w, "html/terms.html")
		}))
		root.Handle("/terms.html", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				http.NotFound(w, r)
				return
			}
			serveHTMLPage(w, "html/terms.html")
		}))
		root.Handle("/support", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				http.NotFound(w, r)
				return
			}
			serveHTMLPage(w, "html/support.html")
		}))
		root.Handle("/support.html", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodGet {
				http.NotFound(w, r)
				return
			}
			serveHTMLPage(w, "html/support.html")
		}))
		root.Handle("/api/receive-stripe-webhook", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			slog.Info("HTTP HandleWebhook (raw): start")
			body, err := io.ReadAll(r.Body)
			if err != nil {
				slog.Error("failed reading body", slog.String("error", err.Error()))
				http.Error(w, "failed to read body", http.StatusBadRequest)
				return
			}
			signature := r.Header.Get("Stripe-Signature")
			if err := bootstrap.Ensure(); err != nil {
				slog.Error("initialization error", slog.String("error", err.Error()))
				http.Error(w, "initialization error", http.StatusInternalServerError)
				return
			}
			if err := grpcserver.HandleWebhookPayload(stripeSvc, body, signature); err != nil {
				slog.Error("webhook handling error", slog.String("error", err.Error()))
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}
			w.WriteHeader(http.StatusOK)
		}))
		// Serve homepage at root and delegate others to grpc-gateway
		root.Handle("/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method == http.MethodGet {
				switch r.URL.Path {
				case "/", "/index", "/index.html":
					serveHTMLPage(w, "html/index.html")
					return
				}
			}
			// Fallback to gRPC-Gateway mux for all other routes
			gwMux.ServeHTTP(w, r)
		}))
		addr := fmt.Sprintf(":%s", httpPort)
		slog.Info("HTTP Gateway server listening", slog.String("address", addr))
		if err := http.ListenAndServe(addr, httpLoggingMiddleware(root)); err != nil {
			slog.Error("failed to serve HTTP Gateway", slog.String("error", err.Error()))
			os.Exit(1)
		}
	}()

	wg.Wait()
}
